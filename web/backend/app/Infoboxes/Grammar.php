<?php
/*
 * Generated by WikiPEG
 */






namespace App\Infoboxes;

class Grammar
{
	static function getNewGrammarParser()
	{
		return new PEGParser();
	}
}

// This must be on a separate line


class PEGParser extends \Wikimedia\WikiPEG\PEGParserBase {
	// initializer
	

private function startOffset()
{
	return $this->savedPos;
}

private function endOffset()
{
	return $this->currPos;
}



	// cache init
	

	// expectations
	protected $expectations = [
		0 => ["type" => "end", "description" => "end of input"],
1 => ["type" => "other", "description" => "start"],
2 => ["type" => "literal", "value" => "\x0a", "description" => "\"\\n\""],
3 => ["type" => "literal", "value" => "\x0d\x0a", "description" => "\"\\r\\n\""],
4 => ["type" => "class", "value" => "[ \\t]", "description" => "[ \\t]"],
5 => ["type" => "literal", "value" => "==", "description" => "\"==\""],
6 => ["type" => "literal", "value" => "=", "description" => "\"=\""],
7 => ["type" => "class", "value" => "[^=]", "description" => "[^=]"],
8 => ["type" => "literal", "value" => "---", "description" => "\"---\""],
9 => ["type" => "literal", "value" => "-", "description" => "\"-\""],
10 => ["type" => "literal", "value" => "Image ", "description" => "\"Image \""],
11 => ["type" => "literal", "value" => "Caption ", "description" => "\"Caption \""],
12 => ["type" => "class", "value" => "[a-zA-Z0-9_ -]", "description" => "[a-zA-Z0-9_ -]"],
13 => ["type" => "literal", "value" => "/", "description" => "\"/\""],
14 => ["type" => "literal", "value" => "\"", "description" => "\"\\\"\""],
15 => ["type" => "class", "value" => "[^'\"']", "description" => "[^'\"']"],
16 => ["type" => "literal", "value" => "'", "description" => "\"'\""],
17 => ["type" => "class", "value" => "[^\"'\"]", "description" => "[^\"'\"]"],
	];

	// actions
	private function a0($$items) {

		return $items;
	
}
private function a1() {
 return $this->endOffset() === 0; 
}
private function a2() {

		return [];
	
}
private function a3($i) {

			return $i;
		
}
private function a4($items) {

		return $items;
	
}
private function a5() {
 return $this->endOffset() === $this->inputLength; 
}
private function a6() {
 return [ new NewLineToken() ]; 
}
private function a7($char) {
 return $char; 
}
private function a8($headerChars) {

		return new InfoboxHeader(trim(implode('', $headerChars)));
	
}
private function a9() {

		return new InfoboxHorizontalLine();
	
}
private function a10($key) {

		return new InfoboxImage($key);
	
}
private function a11($key) {

		return new InfoboxCaption($key);
	
}
private function a12($keys, $keyTitles) {

		$entries = [];

		$numEntries = min(count($keys), count($keyTitles));

		foreach( range(1, $numEntries) as $i )
		{
			$entries[] = new InfoboxEntry($keys[$i], $keyTitles[$i]);
		}

		return $entries;
	
}
private function a13($chars) {

		return trim(implode('', $chars));
	
}
private function a14($firstKey, $otherKey) {

			return otherKey;
		
}
private function a15($firstKey, $otherKeys) {

		return array_merge([$firstKey], $otherKeys);
	
}
private function a16($firstTitle, $otherTitle) {

			return otherTitle;
		
}
private function a17($firstTitle, $otherTitles) {

		return array_merge([$firstTitle], $otherTitles);
	
}

	// generated
	private function parsestart($silence) {
  $p2 = $this->currPos;
  // start seq_1
  $p3 = $this->currPos;
  $r4 = $this->discardstartOfFile(true);
  if ($r4===self::$FAILED) {
    $r1 = self::$FAILED;
    goto seq_1;
  }
  $r5 = $this->parseinfoboxStructure(true);
  // $items <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p3;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  $r6 = $this->discardendOfFile(true);
  if ($r6===self::$FAILED) {
    $this->currPos = $p3;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  $r1 = true;
  seq_1:
  if ($r1!==self::$FAILED) {
    $this->savedPos = $p2;
    $r1 = $this->a0($r5);
  } else {
    if (!$silence) {$this->fail(1);}
  }
  // free $p3
  return $r1;
}
private function discardstartOfFile($silence) {
  $p2 = $this->currPos;
  $this->savedPos = $this->currPos;
  $r1 = $this->a1();
  if ($r1) {
    $r1 = false;
    $this->savedPos = $p2;
    $r1 = $this->a2();
  } else {
    $r1 = self::$FAILED;
  }
  return $r1;
}
private function parseinfoboxStructure($silence) {
  $p2 = $this->currPos;
  $r3 = [];
  for (;;) {
    $p5 = $this->currPos;
    // start seq_1
    $p6 = $this->currPos;
    $r7 = $this->discardanySpacing($silence);
    if ($r7===self::$FAILED) {
      $r4 = self::$FAILED;
      goto seq_1;
    }
    $r8 = $this->parseitem($silence);
    // i <- $r8
    if ($r8===self::$FAILED) {
      $this->currPos = $p6;
      $r4 = self::$FAILED;
      goto seq_1;
    }
    $r9 = $this->discardnewLine($silence);
    if ($r9===self::$FAILED) {
      $this->currPos = $p6;
      $r4 = self::$FAILED;
      goto seq_1;
    }
    $r4 = true;
    seq_1:
    if ($r4!==self::$FAILED) {
      $this->savedPos = $p5;
      $r4 = $this->a3($r8);
      $r3[] = $r4;
    } else {
      break;
    }
    // free $p6
  }
  // items <- $r3
  // free $r4
  $r1 = $r3;
  if ($r1!==self::$FAILED) {
    $this->savedPos = $p2;
    $r1 = $this->a4($r3);
  }
  return $r1;
}
private function discardendOfFile($silence) {
  $p2 = $this->currPos;
  $this->savedPos = $this->currPos;
  $r1 = $this->a5();
  if ($r1) {
    $r1 = false;
    $this->savedPos = $p2;
    $r1 = $this->a2();
  } else {
    $r1 = self::$FAILED;
  }
  return $r1;
}
private function discardanySpacing($silence) {
  $p1 = $this->currPos;
  for (;;) {
    $r3 = $this->discardspacing($silence);
    if ($r3===self::$FAILED) {
      break;
    }
  }
  // free $r3
  $r2 = true;
  if ($r2!==self::$FAILED) {
    $r2 = substr($this->input, $p1, $this->currPos - $p1);
  } else {
    $r2 = self::$FAILED;
  }
  // free $p1
  return $r2;
}
private function parseitem($silence) {
  // start choice_1
  $r1 = $this->parseheader($silence);
  if ($r1!==self::$FAILED) {
    goto choice_1;
  }
  $r1 = $this->parsehorizontalLine($silence);
  if ($r1!==self::$FAILED) {
    goto choice_1;
  }
  $r1 = $this->parseimage($silence);
  if ($r1!==self::$FAILED) {
    goto choice_1;
  }
  $r1 = $this->parsecaption($silence);
  if ($r1!==self::$FAILED) {
    goto choice_1;
  }
  $r1 = $this->parseentry($silence);
  choice_1:
  return $r1;
}
private function discardnewLine($silence) {
  // start choice_1
  $p2 = $this->currPos;
  if (($this->input[$this->currPos] ?? null) === "\x0a") {
    $this->currPos++;
    $r1 = "\x0a";
    $this->savedPos = $p2;
    $r1 = $this->a6();
    goto choice_1;
  } else {
    if (!$silence) {$this->fail(2);}
    $r1 = self::$FAILED;
  }
  $p3 = $this->currPos;
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "\x0d\x0a", $this->currPos, 2, false) === 0) {
    $r1 = "\x0d\x0a";
    $this->currPos += 2;
    $this->savedPos = $p3;
    $r1 = $this->a6();
  } else {
    if (!$silence) {$this->fail(3);}
    $r1 = self::$FAILED;
  }
  choice_1:
  return $r1;
}
private function discardspacing($silence) {
  $r1 = $this->input[$this->currPos] ?? '';
  if ($r1 === " " || $r1 === "\x09") {
    $this->currPos++;
  } else {
    $r1 = self::$FAILED;
    if (!$silence) {$this->fail(4);}
  }
  return $r1;
}
private function parseheader($silence) {
  $p2 = $this->currPos;
  // start seq_1
  $p3 = $this->currPos;
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "==", $this->currPos, 2, false) === 0) {
    $r4 = "==";
    $this->currPos += 2;
  } else {
    if (!$silence) {$this->fail(5);}
    $r4 = self::$FAILED;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  for (;;) {
    if (($this->input[$this->currPos] ?? null) === "=") {
      $this->currPos++;
      $r6 = "=";
    } else {
      if (!$silence) {$this->fail(6);}
      $r6 = self::$FAILED;
      break;
    }
  }
  // free $r6
  $r5 = true;
  if ($r5===self::$FAILED) {
    $this->currPos = $p3;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  // free $r5
  $p7 = $this->currPos;
  $r6 = [];
  for (;;) {
    $r8 = self::charAt($this->input, $this->currPos);
    if ($r8 !== '' && !($r8 === "=")) {
      $this->currPos += strlen($r8);
      $r6[] = $r8;
    } else {
      $r8 = self::$FAILED;
      if (!$silence) {$this->fail(7);}
      break;
    }
  }
  // char <- $r6
  // free $r8
  $r5 = $r6;
  // headerChars <- $r5
  if ($r5!==self::$FAILED) {
    $this->savedPos = $p7;
    $r5 = $this->a7($r6);
  } else {
    $this->currPos = $p3;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "==", $this->currPos, 2, false) === 0) {
    $r8 = "==";
    $this->currPos += 2;
  } else {
    if (!$silence) {$this->fail(5);}
    $r8 = self::$FAILED;
    $this->currPos = $p3;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  for (;;) {
    if (($this->input[$this->currPos] ?? null) === "=") {
      $this->currPos++;
      $r10 = "=";
    } else {
      if (!$silence) {$this->fail(6);}
      $r10 = self::$FAILED;
      break;
    }
  }
  // free $r10
  $r9 = true;
  if ($r9===self::$FAILED) {
    $this->currPos = $p3;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  // free $r9
  $r9 = $this->discardanySpacing($silence);
  if ($r9===self::$FAILED) {
    $this->currPos = $p3;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  $p11 = $this->currPos;
  $r10 = $this->discardnewLine(true);
  if ($r10!==self::$FAILED) {
    $r10 = false;
    $this->currPos = $p11;
  } else {
    $this->currPos = $p3;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  // free $p11
  $r1 = true;
  seq_1:
  if ($r1!==self::$FAILED) {
    $this->savedPos = $p2;
    $r1 = $this->a8($r5);
  }
  // free $p3
  return $r1;
}
private function parsehorizontalLine($silence) {
  $p2 = $this->currPos;
  // start seq_1
  $p3 = $this->currPos;
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "---", $this->currPos, 3, false) === 0) {
    $r4 = "---";
    $this->currPos += 3;
  } else {
    if (!$silence) {$this->fail(8);}
    $r4 = self::$FAILED;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  for (;;) {
    if (($this->input[$this->currPos] ?? null) === "-") {
      $this->currPos++;
      $r6 = "-";
    } else {
      if (!$silence) {$this->fail(9);}
      $r6 = self::$FAILED;
      break;
    }
  }
  // free $r6
  $r5 = true;
  if ($r5===self::$FAILED) {
    $this->currPos = $p3;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  // free $r5
  $r5 = $this->discardanySpacing($silence);
  if ($r5===self::$FAILED) {
    $this->currPos = $p3;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  $p7 = $this->currPos;
  $r6 = $this->discardnewLine(true);
  if ($r6!==self::$FAILED) {
    $r6 = false;
    $this->currPos = $p7;
  } else {
    $this->currPos = $p3;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  // free $p7
  $r1 = true;
  seq_1:
  if ($r1!==self::$FAILED) {
    $this->savedPos = $p2;
    $r1 = $this->a9();
  }
  // free $p3
  return $r1;
}
private function parseimage($silence) {
  $p2 = $this->currPos;
  // start seq_1
  $p3 = $this->currPos;
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "Image ", $this->currPos, 6, false) === 0) {
    $r4 = "Image ";
    $this->currPos += 6;
  } else {
    if (!$silence) {$this->fail(10);}
    $r4 = self::$FAILED;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  $r5 = $this->parsekey($silence);
  // key <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p3;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  $p6 = $this->currPos;
  $r7 = $this->discardnewLine(true);
  if ($r7!==self::$FAILED) {
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $this->currPos = $p3;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $r1 = true;
  seq_1:
  if ($r1!==self::$FAILED) {
    $this->savedPos = $p2;
    $r1 = $this->a10($r5);
  }
  // free $p3
  return $r1;
}
private function parsecaption($silence) {
  $p2 = $this->currPos;
  // start seq_1
  $p3 = $this->currPos;
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "Caption ", $this->currPos, 8, false) === 0) {
    $r4 = "Caption ";
    $this->currPos += 8;
  } else {
    if (!$silence) {$this->fail(11);}
    $r4 = self::$FAILED;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  $r5 = $this->parsekey($silence);
  // key <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p3;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  $p6 = $this->currPos;
  $r7 = $this->discardnewLine(true);
  if ($r7!==self::$FAILED) {
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $this->currPos = $p3;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $r1 = true;
  seq_1:
  if ($r1!==self::$FAILED) {
    $this->savedPos = $p2;
    $r1 = $this->a11($r5);
  }
  // free $p3
  return $r1;
}
private function parseentry($silence) {
  $p2 = $this->currPos;
  // start seq_1
  $p3 = $this->currPos;
  $r4 = $this->parseentryKeys($silence);
  // keys <- $r4
  if ($r4===self::$FAILED) {
    $r1 = self::$FAILED;
    goto seq_1;
  }
  $r5 = $this->discardsomeSpacing($silence);
  if ($r5===self::$FAILED) {
    $this->currPos = $p3;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  $r6 = $this->parseentryKeyTitles($silence);
  // keyTitles <- $r6
  if ($r6===self::$FAILED) {
    $this->currPos = $p3;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  $r1 = true;
  seq_1:
  if ($r1!==self::$FAILED) {
    $this->savedPos = $p2;
    $r1 = $this->a12($r4, $r6);
  }
  // free $p3
  return $r1;
}
private function parsekey($silence) {
  $p2 = $this->currPos;
  $r3 = [];
  for (;;) {
    $r4 = $this->input[$this->currPos] ?? '';
    if (preg_match("/^[a-zA-Z0-9_ \\-]/", $r4)) {
      $this->currPos++;
      $r3[] = $r4;
    } else {
      $r4 = self::$FAILED;
      if (!$silence) {$this->fail(12);}
      break;
    }
  }
  if (count($r3) === 0) {
    $r3 = self::$FAILED;
  }
  // chars <- $r3
  // free $r4
  $r1 = $r3;
  if ($r1!==self::$FAILED) {
    $this->savedPos = $p2;
    $r1 = $this->a13($r3);
  }
  return $r1;
}
private function parseentryKeys($silence) {
  $p2 = $this->currPos;
  // start seq_1
  $p3 = $this->currPos;
  $r4 = $this->parsekey($silence);
  // firstKey <- $r4
  if ($r4===self::$FAILED) {
    $r1 = self::$FAILED;
    goto seq_1;
  }
  $r5 = [];
  for (;;) {
    $p7 = $this->currPos;
    // start seq_2
    $p8 = $this->currPos;
    $r9 = $this->discardanySpacing($silence);
    if ($r9===self::$FAILED) {
      $r6 = self::$FAILED;
      goto seq_2;
    }
    if (($this->input[$this->currPos] ?? null) === "/") {
      $this->currPos++;
      $r10 = "/";
    } else {
      if (!$silence) {$this->fail(13);}
      $r10 = self::$FAILED;
      $this->currPos = $p8;
      $r6 = self::$FAILED;
      goto seq_2;
    }
    $r11 = $this->discardanySpacing($silence);
    if ($r11===self::$FAILED) {
      $this->currPos = $p8;
      $r6 = self::$FAILED;
      goto seq_2;
    }
    $r12 = $this->parsekey($silence);
    // otherKey <- $r12
    if ($r12===self::$FAILED) {
      $this->currPos = $p8;
      $r6 = self::$FAILED;
      goto seq_2;
    }
    $r6 = true;
    seq_2:
    if ($r6!==self::$FAILED) {
      $this->savedPos = $p7;
      $r6 = $this->a14($r4, $r12);
      $r5[] = $r6;
    } else {
      break;
    }
    // free $p8
  }
  // otherKeys <- $r5
  // free $r6
  $r1 = true;
  seq_1:
  if ($r1!==self::$FAILED) {
    $this->savedPos = $p2;
    $r1 = $this->a15($r4, $r5);
  }
  // free $p3
  return $r1;
}
private function discardsomeSpacing($silence) {
  $p1 = $this->currPos;
  $r2 = self::$FAILED;
  for (;;) {
    $r3 = $this->discardspacing($silence);
    if ($r3!==self::$FAILED) {
      $r2 = true;
    } else {
      break;
    }
  }
  if ($r2!==self::$FAILED) {
    $r2 = substr($this->input, $p1, $this->currPos - $p1);
  } else {
    $r2 = self::$FAILED;
  }
  // free $r3
  // free $p1
  return $r2;
}
private function parseentryKeyTitles($silence) {
  $p2 = $this->currPos;
  // start seq_1
  $p3 = $this->currPos;
  $r4 = $this->parseentryKeyTitle($silence);
  // firstTitle <- $r4
  if ($r4===self::$FAILED) {
    $r1 = self::$FAILED;
    goto seq_1;
  }
  $r5 = [];
  for (;;) {
    $p7 = $this->currPos;
    // start seq_2
    $p8 = $this->currPos;
    $r9 = $this->discardanySpacing($silence);
    if ($r9===self::$FAILED) {
      $r6 = self::$FAILED;
      goto seq_2;
    }
    if (($this->input[$this->currPos] ?? null) === "/") {
      $this->currPos++;
      $r10 = "/";
    } else {
      if (!$silence) {$this->fail(13);}
      $r10 = self::$FAILED;
      $this->currPos = $p8;
      $r6 = self::$FAILED;
      goto seq_2;
    }
    $r11 = $this->discardanySpacing($silence);
    if ($r11===self::$FAILED) {
      $this->currPos = $p8;
      $r6 = self::$FAILED;
      goto seq_2;
    }
    $r12 = $this->parseentryKeyTitle($silence);
    // otherTitle <- $r12
    if ($r12===self::$FAILED) {
      $this->currPos = $p8;
      $r6 = self::$FAILED;
      goto seq_2;
    }
    $r6 = true;
    seq_2:
    if ($r6!==self::$FAILED) {
      $this->savedPos = $p7;
      $r6 = $this->a16($r4, $r12);
      $r5[] = $r6;
    } else {
      break;
    }
    // free $p8
  }
  // otherTitles <- $r5
  // free $r6
  $r1 = true;
  seq_1:
  if ($r1!==self::$FAILED) {
    $this->savedPos = $p2;
    $r1 = $this->a17($r4, $r5);
  }
  // free $p3
  return $r1;
}
private function parseentryKeyTitle($silence) {
  // start choice_1
  // start seq_1
  $p2 = $this->currPos;
  if (($this->input[$this->currPos] ?? null) === "\"") {
    $this->currPos++;
    $r3 = "\"";
  } else {
    if (!$silence) {$this->fail(14);}
    $r3 = self::$FAILED;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  $r4 = [];
  for (;;) {
    if (strcspn($this->input, "'\"'", $this->currPos, 1) !== 0) {
      $r5 = self::consumeChar($this->input, $this->currPos);
      $r4[] = $r5;
    } else {
      $r5 = self::$FAILED;
      if (!$silence) {$this->fail(15);}
      break;
    }
  }
  // chars <- $r4
  // free $r5
  if (($this->input[$this->currPos] ?? null) === "\"") {
    $this->currPos++;
    $r5 = "\"";
  } else {
    if (!$silence) {$this->fail(14);}
    $r5 = self::$FAILED;
    $this->currPos = $p2;
    $r1 = self::$FAILED;
    goto seq_1;
  }
  $r1 = [$r3,$r4,$r5];
  seq_1:
  if ($r1!==self::$FAILED) {
    goto choice_1;
  }
  // free $p2
  $p2 = $this->currPos;
  // start seq_2
  $p6 = $this->currPos;
  if (($this->input[$this->currPos] ?? null) === "'") {
    $this->currPos++;
    $r7 = "'";
  } else {
    if (!$silence) {$this->fail(16);}
    $r7 = self::$FAILED;
    $r1 = self::$FAILED;
    goto seq_2;
  }
  $r8 = [];
  for (;;) {
    if (strcspn($this->input, "\"'\"", $this->currPos, 1) !== 0) {
      $r9 = self::consumeChar($this->input, $this->currPos);
      $r8[] = $r9;
    } else {
      $r9 = self::$FAILED;
      if (!$silence) {$this->fail(17);}
      break;
    }
  }
  // chars <- $r8
  // free $r9
  if (($this->input[$this->currPos] ?? null) === "'") {
    $this->currPos++;
    $r9 = "'";
  } else {
    if (!$silence) {$this->fail(16);}
    $r9 = self::$FAILED;
    $this->currPos = $p6;
    $r1 = self::$FAILED;
    goto seq_2;
  }
  $r1 = true;
  seq_2:
  if ($r1!==self::$FAILED) {
    $this->savedPos = $p2;
    $r1 = $this->a13($r8);
  }
  // free $p6
  choice_1:
  return $r1;
}

	public function parse( $input, $options = [] ) {
		$this->initInternal( $input, $options );
		$startRule = $options['startRule'] ?? '(DEFAULT)';
		$result = null;

		if ( !empty( $options['stream'] ) ) {
			switch ( $startRule ) {
				
			default:
				throw new \Wikimedia\WikiPEG\InternalError( "Can't stream rule $startRule." );
			}
		} else {
			switch ( $startRule ) {
				case '(DEFAULT)':
case "start":
  $result = $this->parsestart(false);
  break;
			default:
				throw new \Wikimedia\WikiPEG\InternalError( "Can't start parsing from rule $startRule." );
			}
		}

		if ( $result !== self::$FAILED && $this->currPos === $this->inputLength ) {
			return $result;
		} else {
			if ( $result !== self::$FAILED && $this->currPos < $this->inputLength ) {
				$this->fail( 0 );
			}
			throw $this->buildParseException();
		}
	}
}

