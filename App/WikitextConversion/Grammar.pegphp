/*<?*/
/**
 *
 */

/* ----------------------------------------------------------- */ {

namespace App\WikitextConversion;

use App\WikitextConversion\Tokens\ClosingTagToken;
use App\WikitextConversion\Tokens\EndOfFileToken;
use App\WikitextConversion\Tokens\MetaToken;
use App\WikitextConversion\Tokens\NewLineToken;
use App\WikitextConversion\Tokens\OpeningTagToken;
use App\WikitextConversion\Tokens\SelfClosingTagToken;
use App\WikitextConversion\Tokens\TextToken;

class Grammar
{
	static function getNewGrammarParser()
	{
		return new PEGParser();
	}
}
}
/* ----------------------------------------------------------- */ {

function array_flatten($array = null) {
	$result = array();

	if (!is_array($array)) {
		$array = func_get_args();
	}

	foreach ($array as $key => $value) {
		if (is_array($value))
			$result = array_merge($result, array_flatten($value));
		else
			$result = array_merge($result, array($key => $value));
	}

	return $result;
}

private function startOffset() {
	return $this->savedPos;
}

private function endOffset() {
	return $this->currPos;
}

} /* ----------------------------------------------------------- */

/* == Top-level Rules == */

start "start" =
	blocks:topLevelBlock+ newLine* {
		return array_flatten([ $blocks, new EndOfFileToken() ]);
	}

topLevelBlock =
	block

block =
	blockLines
	/ paragraphLines
	/ nl:newLine anySpacing {
		return $nl;
	}


/* == Block-level Rules == */

blockLines =
	start:startOfLine
	anySpacing block:blockLine {
		return array_merge( $start, $block );
	}

paragraphLines =
	lines:(!paragraphBreak start:startOfLine anySpacing content:inlineContent {
		return [$start, $content];
	})+ {
		$tokens = array();

		$firstLine = $lines[0];
		$innerLines = array_slice($lines, 1, -1);
		$lastLine = end($lines);

		$tokens[] = $firstLine[0];
		$tokens[] = new OpeningTagToken('p');
		$tokens[] = $firstLine[1];

		foreach( $innerLines as $innerLinePair )
		{
			$paragraph[] = $innerLinePair[0];
			$paragraph[] = $innerLinePair[1];
		}

		if( sizeof($lines) > 1 )
		{
			$tokens[] = $lastLine[0];
			$tokens[] = $lastLine[1];
		}
		$tokens[] = new ClosingTagToken('p');

		return $tokens;
	}

paragraphBreak =
	&blockLines
	/ newline1:newLine
	anySpacing
	newline2:newLine {
		return array_merge( $newline1, $newline2 );
	}


/* == Block-style Rules == */

// Matches on a single line, assuming a newline both follows and leads.
blockLine =
	heading
	/ listItem

heading =
	anySpacing '==' inner:innerHeadingContent '==' anySpacing
	{
		$level = $inner['level'];
		$text = $inner['text'];
		$trimmedText = trim(trim($text, '='));

		return [
			new OpeningTagToken('h' . $level),
			new TextToken($trimmedText),
			new ClosingTagToken('h' . $level)
		];
	}

innerHeadingContent =
	'=' inner:innerHeadingContent '=' {
		$inner['level'] += 1;
		return $inner;
	}
	/ innerText:$inlineText {
		return [ 'level' => 1, 'text' => $innerText ];
	}

listCharacter = [*#:;]

listItem =
	bullets:listCharacter+ content:inlineContent? {
		return array_merge(
			new MetaToken('ListItem', [ 'bullets' => bullets ]),
			$content ?: []);
	}

/* == Line/Paragraph-style Rules == */

inlineContent =
	inlineLine
	/ inlineText

inlineLine =
	content:( !inlineBreak element:(inlineElement / [^\r\n]) { return $element; } )+ 
	{
		$lineContents = [];
		$textBuffer = '';
		foreach( $content as $element )
		{
			if ( is_string( $element ) )
				$textBuffer .= $element;
			else
			{
				if ( $textBuffer !== '' )
				{
					$lineContents[] = new TextToken($textBuffer);
					$textBuffer = '';
				}
				$lineContents[] = $element;
			}
		}
		if ( $textBuffer !== '' )
			$lineContents[] = new TextToken($textBuffer);

		return $lineContents;
	}

inlineBreak =
	&'[['
	/ &"'''"
	/ &"''"
	/ &'{{'
	/ &newLine

inlineElement =
	& '[' element:( wikilink ) { return $element; }
	/ & "'" element:quotedContent { return $element; }

inlineText =
	text:[^\n\r]+ {
		return [ new TextToken(implode('', $text)) ];
	}


/* == Inline Rules == */

wikilink =
	"[[" target:$[^\]|]* exactText:("|" text:$[^\]] { return $text; })? "]]" {
		$linkTarget = '/#' . ucwords(str_replace(' ', '_', trim($target)), '_-');
		$linkText = trim($exactText) ?: trim($target);
		return [
			new OpeningTagToken('a', [
				'href' => $linkTarget
			]),
			new TextToken($linkText),
			new ClosingTagToken('a')
		];
	}

quotedContent = bold / italics

bold =
	"'''" content:inlineContent "'''" {
		return array_merge(
			[ new OpeningTagToken('b') ],
			$content,
			[ new ClosingTagToken('b') ]
		);
	}

italics =
	"''" content:inlineContent "''" {
		return array_merge(
			[ new OpeningTagToken('i') ],
			$content,
			[ new ClosingTagToken('i') ]
		);
	}


/* == Positional Rules == */

startOfLine =
	newLine
	/ startOfFile

newLine = 
	'\n' { return [ new NewLineToken() ]; }
	/ '\r\n' { return [ new NewLineToken() ]; }

startOfFile =
	& { return $this->endOffset() === 0; } {
		return [];
	}

someSpacing =
	$spacing+

anySpacing =
	$spacing*

spacing =
	[ \t]
