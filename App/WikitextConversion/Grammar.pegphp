/*<?*/
/**
 *
 */

/* ----------------------------------------------------------- */ {

namespace App\WikitextConversion;

use App\WikitextConversion\Tokens\ClosingTagToken;
use App\WikitextConversion\Tokens\EndOfFileToken;
use App\WikitextConversion\Tokens\MetaToken;
use App\WikitextConversion\Tokens\NewLineToken;
use App\WikitextConversion\Tokens\OpeningTagToken;
use App\WikitextConversion\Tokens\SelfClosingTagToken;
use App\WikitextConversion\Tokens\TextToken;

class Grammar
{
	static function getNewGrammarParser()
	{
		return new PEGParser();
	}
}
}
/* ----------------------------------------------------------- */ {

function array_flatten($array = null) {
	$result = array();

	if (!is_array($array)) {
		$array = func_get_args();
	}

	foreach ($array as $key => $value) {
		if (is_array($value))
			$result = array_merge($result, array_flatten($value));
		else
			$result = array_merge($result, array($key => $value));
	}

	return $result;
}

private function startOffset() {
	return $this->savedPos;
}

private function endOffset() {
	return $this->currPos;
}

} /* ----------------------------------------------------------- */

/* == Top-level Rules == */

start "start" =
	blocks:topLevelBlock+ newLine* {
		return array_flatten([ $blocks, new EndOfFileToken() ]);
	}

topLevelBlock =
	block

block =
	blockLines
	/ paragraphLines
	/ nl:newLine anySpacing {
		return $nl;
	}


/* == Block-level Rules == */

blockLines =
	start:startOfLine anySpacing block:blockLine {
		return array_merge( $start, $block );
	}

paragraphLines =
	lines:(!paragraphBreak start:startOfLine anySpacing content:trimmedInlineLine {
		return [$start, $content];
	})+ {
		$tokens = array();

		$firstLine = $lines[0];
		$innerLines = array_slice($lines, 1, -1);
		$lastLine = end($lines);

		// A line is a pair [newline, content].

		$tokens[] = $firstLine[0];
		$tokens[] = new OpeningTagToken('p');
		$tokens = array_merge($tokens, $firstLine[1]);

		foreach( $innerLines as $innerLinePair )
		{
			$tokens[] = $innerLinePair[0];
			$tokens[] = array_merge($tokens, $innerLinePair[1]);
		}

		if( sizeof($lines) > 1 )
		{
			$tokens[] = $lastLine[0];
			$tokens = array_merge($tokens, $lastLine[1]);
		}
		$tokens[] = new ClosingTagToken('p');

		return $tokens;
	}

paragraphBreak =
	blockLines
	/ newline1:newLine
	anySpacing
	newline2:newLine {
		return array_merge( $newline1, $newline2 );
	}


/* == Block Rules == */

// Matches on a single line, assuming a newline both follows and leads.
blockLine =
	header
	/ listItem

header =
	anySpacing '==' extrasLeft:'='* inner:innerHeaderContent '==' extrasRight:'='* anySpacing
	{
		$level = strval( 2 + min( count($extrasLeft), count($extrasRight) ) );
		$textToken = new TextToken($inner);
		$textToken->trim();

		return [
			new OpeningTagToken('h' . $level),
			$textToken,
			new ClosingTagToken('h' . $level)
		];
	}

innerHeaderContent =
	innerText:$inlineText<header> {
		return $innerText;
	}

listItem =
	bullets:listCharacter+ content:inlineContent? {
		return array_merge(
			new MetaToken('ListItem', [ 'bullets' => bullets ]),
			$content ?: []);
	}

listCharacter = [*#:;]


/* == Inline Rules == */

inlineContent =
	inlineLine

trimmedInlineLine =
	line:inlineLine {

		if ( is_a($line[0], TextToken::class) )
			$line[0]->ltrim();

		if ( is_a( end($line), TextToken::class ) )
			end($line)->rtrim();

		return $line;
	}

// This can have a template passed to it to represent the context, which affects what is counted as an inline break.
inlineLine =
	content:( !inlineBreak element:(inlineElement / .) { return $element; } )+ 
	{
		$lineContents = [];
		$textBuffer = '';
		foreach( $content as $element )
		{
			if ( is_string( $element ) )
				$textBuffer .= $element;
			else
			{
				if ( $textBuffer !== '' )
				{
					$lineContents[] = new TextToken( $textBuffer );
					$textBuffer = '';
				}
				$lineContents[] = $element;
			}
		}
		if ( $textBuffer !== '' )
			$lineContents[] = new TextToken( $textBuffer );
		
		return $lineContents;
	}

inlineElement =
	& '[' element:( wikilink ) { return $element; }
	/ & "'" element:quotedContent { return $element; }

// This can have a template passed to it to represent the context, which affects what is counted as an inline break.
inlineText =
	text:( !inlineBreak c:. { return $c; } )+ 
	{
		return [ new TextToken( implode('', $text) ) ];
	}

inlineBreak =
	& newLine
	/ & <header> & '=='
	/ & <bold> & "'''"
	/ & <italics> & "''" ! "'''"

/* == Inline Rules == */

wikilink =
	"[[" target:$[^\]|]* exactText:("|" text:$[^\]]+ { return $text; })? "]]" {
		$linkTarget = '\'/#' . ucwords(str_replace(' ', '_', trim($target)), '_-') . '\'';
		$linkText = trim($exactText ?: $target);
		return [
			new OpeningTagToken('a', [
				'href' => $linkTarget
			]),
			new TextToken( trim($linkText) ),
			new ClosingTagToken('a')
		];
	}

quotedContent = bold / italics

bold =
	"'''" !"'" content:inlineContent<bold> "'''" !"'" {
		return array_merge(
			[ new OpeningTagToken('b') ],
			$content,
			[ new ClosingTagToken('b') ]
		);
	}

italics =
	"''" !"'" content:inlineContent<italics> "''" {
		return array_merge(
			[ new OpeningTagToken('i') ],
			$content,
			[ new ClosingTagToken('i') ]
		);
	}


/* == Positional Rules == */

startOfLine =
	newLine
	/ startOfFile

newLine = 
	'\n' { return [ new NewLineToken() ]; }
	/ '\r\n' { return [ new NewLineToken() ]; }

startOfFile =
	& { return $this->endOffset() === 0; } {
		return [];
	}

someSpacing =
	$spacing+

anySpacing =
	$spacing*

spacing =
	[ \t]
